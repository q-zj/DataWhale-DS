## 理论部分
https://github.com/datawhalechina/team-learning/blob/master/数据结构与算法（上）/1_数组.md

## 代码部分
https://github.com/datawhalechina/team-learning/blob/master/数据结构与算法（上）/学习任务.md
### 00动态数组
```Java
//基于Java的array，完成初始化、增减查改、增减到一定程度则自动改变数组长度

package qzj;

public class DynamicArray<E> {

	//实例域
    private int size;
    private Object[] data; 
    private int capacity;
    //有参构造方法
    public DynamicArray(int capacity) {
        size = 0;
        data = new Object[capacity];
        this.capacity = capacity;
    }
    //无参构造方法
    public DynamicArray() {
        this(10);   //默认初始化长度为10的
    }
    //get,set方法
    public int getSize() {
    	return size;
    }
    public int getCapacity() {
    	return data.length;
    }
    //增加，参数审查index，判断size与capacity的关系,加长，后移之后的元素,
    //三种情况，头（原序列空序列），尾，中间
    public void add(int index, E e) {
    	if(index<0 || index>data.length)
    		throw new IllegalArgumentException("index is smaller than 0 or bigger than capacity");
    	if(size == data.length)
    		resize(2*data.length);
    	for(int i=size-1;i>index;i--) { //若只有i满足条件才会运行，即若i一开始就小于index则不会循环
    		data[i+1]=data[i];
    	}
    	data[index] = e;
    	size++;
    }
    //append
    public void append(E e) {
    	add(size, e);
    }
    //删除并返回值，情况：空数组;删除尾巴;
    //缩进数组,避免重复的增减导致数组长度一直改变，使得复杂度震荡，当size=capacity/4(取整)且保证capacity/2！=0
    public E delete(int index) {
    	if(index<0 || index>=size) //包含空数组
    		throw new IllegalArgumentException("illegal index");
    	if(size==data.length/4 && data.length/2!=0) { //
    		resize(data.length/2);
    	}
    	Object temp = data[index];
    	for(int i=index+1;i<size;i++) { //包含删除尾巴
    		data[i-1] = data[i];
    	}
    	size--;
    	data[size] = null;
    	return (E) temp;
    }
    //查找index并返回
    public E getIndex(int index) {
    	if(index<0 || index>size)
    		throw new IllegalArgumentException("index is smaller than 0 or bigger than size");
    	return (E) data[index];
    }
    //修改
    public void change(int index, E e) {
    	if(index<0 || index>size)
    		throw new IllegalArgumentException("index is smaller than 0 or bigger than size");
    	data[index] = e;
    }
    //实现自动改变大小
    public void resize(int newCapacity) {
    	Object[] newArray = new Object[newCapacity];
    	for(int i=0;i<size;i++) //size保证总是小于newArray的capacity
    		newArray[i] = data[i];
    	data = newArray;	
    }
    //判断是否为空
    public boolean isEmpty() {
    	return size == 0;
    }
    //显示数组
    @Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length));
		res.append("[");
		for (int i = 0; i < size; i++) {
			res.append(data[i]);
			if (i != size - 1)
				res.append(", ");
		}
		res.append("]");
		return res.toString();
	}
}

```
### 01 利用动态数组解决数据存放问题
```Java
//基于00构造的DynamicArray
package qzj;
import java.util.*;
public class UseDynamicArray {
	public static void main(String[] args) {
		System.out.println("input number:");
		Scanner in = new Scanner(System.in);
		int max = in.nextInt();
		DynamicArray<Integer> o = new DynamicArray<Integer>(1);
		if(max<2)
			throw new IllegalArgumentException("input error");
		for(int i=2;i<=max;i++) {
			if((i%5)*(i%7)==0) {
				Integer ii = Integer.valueOf(i);
				o.append(ii);
			}
		}
		String res = o.toString();
		System.out.print(res);

	}
}
```
### 02 托普利茨矩阵问题
```Java
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
        Map<Integer, Integer> groups = new HashMap();
        for (int r = 0; r < matrix.length; ++r) {
            for (int c = 0; c < matrix[0].length; ++c) {
                if (!groups.containsKey(r-c))
                    groups.put(r-c, matrix[r][c]);
                else if (groups.get(r-c) != matrix[r][c])
                    return False;
            }
        }
        return True;
    }
}
```
### 03 三数之和
```Java
class Solution {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if(nums == null || len < 3) return ans;
        Arrays.sort(nums); // 排序
        for (int i = 0; i < len ; i++) {
            if(nums[i] > 0) break; 
            if(i > 0 && nums[i] == nums[i-1]) continue; //
            int L = i+1;
            int R = len-1;
            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));
                    while (L<R && nums[L] == nums[L+1]) L++; // 
                    while (L<R && nums[R] == nums[R-1]) R--; // 
                    L++;
                    R--;
                }
                else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }        
        return ans;
    }
}
```
